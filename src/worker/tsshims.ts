

//This file is autogenerated. Do not edit.



import Module, {Manifold, ManifoldToplevel, Mat4, Vec3} from "../ext/manifold/manifold.js";
import { ManifoldMeshWrapper, MeshHandle, manifoldMeshes } from "./workertypes.js";
let manifold: ManifoldToplevel;

export function setManifold(m: ManifoldToplevel){
    manifold=m;
}
type PyColor = [number,number,number,number?];
type TransformFunction = (m: Manifold) => Manifold;

function transformAroundCentroid(centroid: Vec3|undefined, color: PyColor|undefined, obj: ManifoldMeshWrapper, callback: TransformFunction)
{
    let cx: number;
    let cy: number;
    let cz: number;
    if( !centroid ){
        //transform object around its own centroid
        let bbox = obj.mesh.boundingBox();
        let cx = 0.5*( bbox.min[0] + bbox.max[0] );
        let cy = 0.5*( bbox.min[1] + bbox.max[1] );
        let cz = 0.5*( bbox.min[2] + bbox.max[2] );
    } else {
        cx = centroid[0];
        cy = centroid[1];
        cz = centroid[2];
    }

    if( cx === 0.0 && cy === 0.0 && cz === 0.0 ){
        //fast path
        let ob = callback( obj.mesh );
        return new ManifoldMeshWrapper( ob, color ?? obj.color );
    } else {
        let o2 = obj.mesh.translate([-cx,-cy,-cz]);
        let o3 = callback( o2 );
        o2.delete();
        let o4 = o3.translate([cx,cy,cz]);
        o3.delete();
        return new ManifoldMeshWrapper(o4, color ?? obj.color );
    }
}


function computeRotationMatrix(x:number,y:number,z:number,angle:number){
    angle = angle / 180 * Math.PI;
    let c = Math.cos(angle);
    let c1 = 1-c;
    let s = Math.sin(angle);
    //this is in COLUMN major order!
    //ref: https://en.wikipedia.org/wiki/Rotation_matrix
    //ref: https://ai.stackexchange.com/questions/14041/how-can-i-derive-the-rotation-matrix-from-the-axis-angle-rotation-vector
    let M: Mat4 = [
        x*x*c1+c,
        x*y*c1+z*s,
        x*z*c1-y*s,
        0,

        y*x*c1-z*s,
        y*y*c1+c,
        y*z*c1+x*s,
        0,

        x*z*c1+y*s,
        y*z*c1-x*s,
        z*z*c1+c,
        0,

        0,0,0,1
    ]
    return M;
}


type free_t = ( obj : MeshHandle ) => void ;
declare global {
    interface WorkerGlobalScope { impl_free : free_t }
};

self.impl_free = ( obj : MeshHandle ) : void => {

    let mw = manifoldMeshes[obj.index];
    mw.mesh.delete();
    mw.freed=true;

}
type box_t = ( min : Vec3,max : Vec3,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_box : box_t }
};

self.impl_box = ( min : Vec3,max : Vec3,color : PyColor ) : MeshHandle => {

    let xsize = max[0]-min[0];
    let ysize = max[1]-min[1];
    let zsize = max[2]-min[2];
    if( xsize<=0 )
        throw new Error("box(): max x <= min x");
    if( ysize<=0 )
        throw new Error("box(): max y <= min y");
    if( zsize<=0 )
        throw new Error("box(): max z <= min z");

    let c = manifold.Manifold.cube(
        [xsize, ysize, zsize],
        false
    );
    let c2 = c.translate(min);
    c.delete()
    return new MeshHandle( new ManifoldMeshWrapper(c2,color) );

}
type cube_t = ( xsize : number,ysize : number,zsize : number,x : number,y : number,z : number,centered : boolean,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_cube : cube_t }
};

self.impl_cube = ( xsize : number,ysize : number,zsize : number,x : number,y : number,z : number,centered : boolean,color : PyColor ) : MeshHandle => {

    let c = manifold.Manifold.cube(
        [xsize, ysize, zsize],
        centered
    );
    let c2 = c.translate([x,y,z]);
    c.delete()
    return new MeshHandle( new ManifoldMeshWrapper(c2,color) );

}
type sphere_t = ( radius : number,x : number,y : number,z : number,color : PyColor,resolution : number ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_sphere : sphere_t }
};

self.impl_sphere = ( radius : number,x : number,y : number,z : number,color : PyColor,resolution : number ) : MeshHandle => {

    let s = manifold.Manifold.sphere(radius, resolution);
    let s2 = s.translate([x, y,z]);
    s.delete();
    return new MeshHandle( new ManifoldMeshWrapper(s2,color) );

}
type cylinder_t = ( x : number,y : number,z : number,radius : number,height : number,zcenter : boolean,color : PyColor,resolution : number ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_cylinder : cylinder_t }
};

self.impl_cylinder = ( x : number,y : number,z : number,radius : number,height : number,zcenter : boolean,color : PyColor,resolution : number ) : MeshHandle => {

    let c = manifold.Manifold.cylinder(height,
        radius, radius, resolution,
        zcenter
    );
    let c2 = c.translate([x, y, z]);
    c.delete();
    return new ManifoldMeshWrapper(c2,color);

}
type frustum_t = ( radius1 : number,radius2 : number,height : number,x : number,y : number,z : number,zcenter : boolean,color : PyColor,resolution : number ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_frustum : frustum_t }
};

self.impl_frustum = ( radius1 : number,radius2 : number,height : number,x : number,y : number,z : number,zcenter : boolean,color : PyColor,resolution : number ) : MeshHandle => {

    let c = manifold.Manifold.cylinder(height,
        radius1, radius2, resolution,
        zcenter
    );
    let c2 = c.translate([x, y, z]);
    c.delete();
    return new ManifoldMeshWrapper(c2,color);

}
type union_t = ( objects : MeshHandle[],color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_union : union_t }
};

self.impl_union = ( objects : MeshHandle[],color : PyColor ) : MeshHandle => {

    if( objects.length === 1 )
        return objects[0];
    let ob = manifold.Manifold.union( objects[0].mesh, objects[1].mesh );
    for(let i=2;i<objects.length;++i){
        let ob2 = manifold.Manifold.union( ob, objects[i].mesh );
        ob.delete();
        ob=ob2;
    }
    let color = (color ?? objects[0].color);
    return new ManifoldMeshWrapper(ob,color);

}
type intersection_t = ( objects : MeshHandle[],color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_intersection : intersection_t }
};

self.impl_intersection = ( objects : MeshHandle[],color : PyColor ) : MeshHandle => {

    if( objects.length === 1 )
        return objects[0];
    let ob = manifold.Manifold.intersection( objects[0].mesh, objects[1].mesh );
    for(let i=2;i<objects.length;++i){
        let ob2 = manifold.Manifold.intersection( ob, objects[i].mesh );
        ob.delete();
        ob=ob2;
    }
    let color = (color ?? objects[0].color);
    return new ManifoldMeshWrapper(ob,color);

}
type difference_t = ( objects : MeshHandle|MeshHandle[],color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_difference : difference_t }
};

self.impl_difference = ( objects : MeshHandle|MeshHandle[],color : PyColor ) : MeshHandle => {

    if( objects.length === 1 )
        return objects[0];
    let ob = manifold.Manifold.difference( objects[0].mesh, objects[1].mesh );
    for(let i=2;i<objects.length;++i){
        let ob2 = manifold.Manifold.difference( ob, objects[i].mesh );
        ob.delete();
        ob=ob2;
    }
    let color = (color ?? objects[0].color);
    return new ManifoldMeshWrapper(ob,color);

}
type translate_t = ( objects : MeshHandle|MeshHandle[],tx : number,ty : number,tz : number,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_translate : translate_t }
};

self.impl_translate = ( objects : MeshHandle|MeshHandle[],tx : number,ty : number,tz : number,color : PyColor ) : MeshHandle => {

    let objs: MeshHandle[];
    if( objects.length === undefined ){
        //it's a single object
        objs = [ objects ];
    } else {
        //it's a list
        objs = objects;
    }

    let output: MeshHandle[] = [];
    for(let i=0;i<objs.length;++i){
        let ob = objs[i].mesh.translate( tx,ty,tz );
        output.push(new MeshHandle( new ManifoldMeshWrapper( ob, color ?? objs[i].color ) ) );
    }

    if( objects.length === undefined ){
        //single object in; single object out
        return output[0];
    } else {
        //list in; list out
        return output;
    }
}


}
type scale_t = ( objects : MeshHandle|MeshHandle[],sx : number,sy : number,sz : number,centroid : Vec3,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_scale : scale_t }
};

self.impl_scale = ( objects : MeshHandle|MeshHandle[],sx : number,sy : number,sz : number,centroid : Vec3,color : PyColor ) : MeshHandle => {

    let objs: MeshHandle[];
    if( objects.length === undefined ){
        //it's a single object
        objs = [ objects as ManifoldMeshWrapper ];
    } else {
        //it's a list
        objs = objects as ManifoldMeshWrapper[];
    }

    let output: ManifoldMeshWrapper[] = [];
    for(let i=0;i<objs.length;++i){
        output.push( transformAroundCentroid( centroid, color, objs[i],
            (m: Manifold) => { return m.scale(sx,sy,sz); }
        ));
    }

    if( objects.length === undefined ){
        //single object in; single object out
        return [ new MeshHandle(output[0]) ];
    } else {
        //list in; list out
        let tmp: MeshHandle[] = [];
        for(let i=0;i<output.length;++i)
            tmp.push(new MeshHandle(output[i]));
        return tmp;
    }
}

}
type rotate_t = ( objects : MeshHandle|MeshHandle[],axis : Vec3,angle : number,centroid : Vec3,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_rotate : rotate_t }
};

self.impl_rotate = ( objects : MeshHandle|MeshHandle[],axis : Vec3,angle : number,centroid : Vec3,color : PyColor ) : MeshHandle => {

    let objs: MeshHandle[];
    if( objects.length === undefined ){
        //it's a single object
        objs = [ objects ];
    } else {
        //it's a list
        objs = objects ;
    }


    let output: ManifoldMeshWrapper[] = [];

    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x*x+y*y+z*z);
    //Python code already verified that length is not zero
    x /= len;
    y /= len;
    z /= len;

    let rotV: Vec3;
    if( x === 1.0 && y === 0.0 && z === 0.0 ){
        rotV = [angle,0,0];
    } else if( x === -1.0 && y === 0.0 && z === 0.0 ){
        rotV = [-angle,0,0];
    } else if( x ===  0.0 && y === 1.0 && z === 0.0 ){
        rotV = [0,angle,0];
    } else if( x ===  0.0 && y === -1.0 && z === 0.0 ){
        rotV = [0,-angle,0];
    } else if( x ===  0.0 && y === 0.0 && z === 1.0 ){
        rotV = [0,0,angle];
    } else if( x ===  0.0 && y === 0.0 && z === -1.0 ){
        rotV = [0,0,-angle];
    } else {
        //need to use slow path
    }

    if( rotV !== undefined ){
        for(let i=0;i<objs.length;++i){
            output.push( transformAroundCentroid( centroid, color, objs[i],
                (m: Manifold) => { return m.rotate(rotV); }
            ));
        }
    } else {
        let M = computeRotationMatrix(x,y,z,angle);
        for(let i=0;i<objs.length;++i){
            output.push( transformAroundCentroid( centroid, color, objs[i],
                (m: Manifold) => { return m.transform(M); }
            ));
        }
    }

    if( objects.length === undefined ){
        //single object in; single object out
        return new MeshHandle(output[0]);
    } else {
        //list in; list out
        let tmp: MeshHandle[] = [];
        for(let i=0;i<output.length;++i)
            tmp.push(new MeshHandle(output[i]));
        return tmp;
    }
}

}
type hull_t = ( objects : MeshHandle|MeshHandle[],color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_hull : hull_t }
};

self.impl_hull = ( objects : MeshHandle|MeshHandle[],color : PyColor ) : MeshHandle => {

    let ob: Manifold;
    let needFree=false;

    if( objects.length === undefined ){
        //one object
        ob = objects;
    } else if( objects.length === 1 ){
        ob = objects[0];
    } else {
        //Python code ensured length of list > 0
        let ob = manifold.Manifold.union( objects[0].mesh, objects[1].mesh );
        for(let i=2;i<objects.length;++i){
            let ob2 = manifold.Manifold.union( ob, objects[i].mesh );
            ob.delete();
            ob=ob2;
        }
        needFree=true;
    }

    let o2 = manifold.Manifold.hull(ob);
    if(needFree)
        ob.delete()

    return new ManifoldMeshWrapper( o2, color ?? ob.color );

}
type boundingbox_t = ( objects : MeshHandle|MeshHandle[] ) => Vec3[] ;
declare global {
    interface WorkerGlobalScope { impl_boundingbox : boundingbox_t }
};

self.impl_boundingbox = ( objects : MeshHandle|MeshHandle[] ) : Vec3[] => {

    let objs: MeshHandle[] = [];
    if( objects.length === undefined ){
        objs = [objects];
    else
        objs = objects;
    let mw:ManifoldMeshWrapper = manifoldMeshes[objs[0].index];
    let tmp = mw.mesh.boundingbox()
    let minimum = tmp[0];
    let maximum = tmp[1];
    for(let i=1;i<objs.length;++i){
        mw = manifoldMeshes[objs[i].index];
        tmp = mw.mesh.boundingbox();
        for(let i=0;i<3;++i){
            if( tmp[0][i] < minimum[i] )
                minimum[i] = tmp[0][i];
            if( tmp[1][i] > maximum[i] )
                maximum[i] = tmp[1][i];
        }
    }
    return [ minimum, maximum ];
}

}
type cut_t = ( object : MeshHandle,planeNormal : Vec3,planeD : number,keepPositive : boolean,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_cut : cut_t }
};

self.impl_cut = ( object : MeshHandle,planeNormal : Vec3,planeD : number,keepPositive : boolean,color : PyColor ) : MeshHandle => {

    let results = object.mesh.splitByPlane( planeNormal, planeD);
    let ki = ( keepPositive ? 0 : 1 );
    results[1-ki].delete();
    return new ManifoldMeshWrapper( results[ki], spec.color ?? object.color );

}
type extrude_t = ( polygon : vec2[],height : number,divisions : number,twist : number,scale : Vec2,zcenter : boolean,color : PyColor ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_extrude : extrude_t }
};

self.impl_extrude = ( polygon : vec2[],height : number,divisions : number,twist : number,scale : Vec2,zcenter : boolean,color : PyColor ) : MeshHandle => {

    let o1 = manifold.Manifold.extrude(
            polygon,
            height ?? 1,
            divisions ?? 1,
            twist ?? 0,
            scale ?? [1,1],
            zcenter
    );
    return new ManifoldMeshWrapper( o1, color );

}
type revolve_t = ( polygon : vec2[],angle : number,color : PyColor,resolution : number ) => MeshHandle ;
declare global {
    interface WorkerGlobalScope { impl_revolve : revolve_t }
};

self.impl_revolve = ( polygon : vec2[],angle : number,color : PyColor,resolution : number ) : MeshHandle => {

    let o1 = manifold.Manifold.revolve(
            polygon,
            resolution ?? 36,
            angle ?? 360
    );
    return new ManifoldMeshWrapper( o1, color );


}
