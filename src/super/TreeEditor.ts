
declare var $:any;

export class Point3{
    x:number;
    y:number;
    z:number;
    constructor(x:number, y:number, z:number){
        this.x=x;
        this.y=y;
        this.z=z;
    }
}

interface NodeState{
    opened: boolean;
    disabled: boolean;
    selected: boolean;
}

interface Coordinate{
    x: number;
    y: number;
};

interface ContextItemEntry{
    separator_before?:boolean;
    separator_after?:boolean;
    _disabled?:boolean;
    label:string;
    title?:string;      //tooltip
    action: ContextItemChosenCallback;
    icon?: string;   //if it contains '/': path to icon. Else, css class name
    shortcut?: number;  //keyCode for the action. Ex from jstree docs: F2=113
    shortcut_label?: string;
    submenu?: ContextItemsDict;
};
interface ContextItemChosenData {
    item: ContextItemEntry; //from original item definition
    reference: HTMLElement; //DOM node for the tree node
    element: HTMLElement;   //DOM element for the context menu
    position: Coordinate;   //where the menu is
};

type ContextItemsDict = {[name: string] : ContextItemEntry} ;  //Record<string,ContextItemEntry>;
type ContextItemsCallback = (items: ContextItemsDict) => void;
type ContextItemChosenCallback = ( data:ContextItemChosenData ) => void;

enum PropertyType{
    POINT3, NUMBER, POSITIVE_NUMBER, BOOLEAN
}

type PropertyGetter<T> = ()=>T;
type PropertySetter<T> = (value:T) => void;
type PropertyChangeCallback = ()=>void;

class GenericProperty<T>{
    name: string;
    type: PropertyType;
    private getter: PropertyGetter<T>;
    private setter: PropertySetter<T>;
    changeCallbacks: PropertyChangeCallback[] = [];
    constructor(name:string,type: PropertyType, getter: PropertyGetter<T>, setter: PropertySetter<T>){
        this.name=name;
        this.type=type;
        this.getter=getter;
        this.setter=setter;
    }
    addChangeListener( f: PropertyChangeCallback){
        this.changeCallbacks.push(f);
    }
    canSetValue(){
        return this.setter !== undefined ;
    }
    setValue(v:T){
        this.setter(v);
        this.changeCallbacks.forEach( (f: PropertyChangeCallback) => {
            f();
        });
    }
    getValue() {
        return this.getter();
    }
}

class NumberProperty extends GenericProperty<number>{
    constructor(name:string, getter: PropertyGetter<number>, setter: PropertySetter<number>){
        super(name,PropertyType.NUMBER,getter,setter);
    }
}


class PositiveNumberProperty extends NumberProperty{
    constructor(name:string, getter: PropertyGetter<number>, setter: PropertySetter<number>){
        super(name,getter,setter);
        this.type = PropertyType.POSITIVE_NUMBER;
    }
}


class BooleanProperty extends GenericProperty<boolean>{
    constructor(name:string, getter: PropertyGetter<boolean>, setter: PropertySetter<boolean>){
        super(name,PropertyType.BOOLEAN,getter,setter);
    }
}


class Point3Property extends GenericProperty<Point3>{
    constructor(name:string, getter: PropertyGetter<Point3>, setter: PropertySetter<Point3>){
        super(name,PropertyType.POINT3,getter,setter);
    }
}

type AnyProperty = NumberProperty|Point3Property|BooleanProperty;

class TreeNode{
    id: string;                 //autogenerated if not present
    text: string;               
    icon: string|boolean;       //If icon contains /: Interpreted as path to image
                                //if false: No icon.
                                //else, interpreted as css class to apply to an <i> element
    state: NodeState;
    children: TreeNode[] = [];
    li_attr: any;               //attributes for the generated li node
    a_attr: any;                 //attributes for the generated a node
    type: string;               //for type jstree plugin

    properties: AnyProperty[] = [];

    constructor(text:string, type: string){
        this.text=text;
        this.state = { 
            opened: true,
            disabled: false,
            selected: false
        };
        this.type=type;
    }
}

class TreeNodeWithChildren extends TreeNode {
    constructor(name: string, type: string){
        super(name,type);
    }
    appendChild(n:TreeNode){
        this.children.push(n);
    }
}

class DifferenceNode extends TreeNodeWithChildren {
    constructor(name: string){
        super(name,"difference");
        this.properties=[];
    }

}


class UnionNode extends TreeNodeWithChildren {
    constructor(name: string){
        super(name,"union");
        this.properties=[];
    }
}



class IntersectionNode extends TreeNodeWithChildren {
    constructor(name: string){
        super(name,"intersection");
        this.properties=[];
    }
}


class BoxNode extends TreeNode {
    min: Point3 = new Point3(0,0,0);
    max: Point3 = new Point3(1,1,1);
    constructor(name:string){
        super(name,"box");
        this.properties = [
            new Point3Property("min",
                ()=>{ return this.min},
                (p:Point3) => { 
                    this.min=p;
                }
            ),
            new Point3Property("max",
                ()=>{ return this.max},
                (p:Point3) => { 
                    this.max=p;
                }
            ),

            //read only properties
            new NumberProperty( "xsize",
                ()=>{ return this.max.x-this.min.x},
                undefined
            ),
            new NumberProperty( "ysize",
                ()=>{ return this.max.y-this.min.y},
                undefined
            ),
            new NumberProperty( "zsize",
                ()=>{ return this.max.z-this.min.z},
                undefined
            ),
            new Point3Property( "centroid",
                ()=>{ 
                    return new Point3(0.5*(this.min.x+this.max.x),
                                      0.5*(this.min.y+this.max.y),
                                      0.5*(this.min.z+this.max.z));
                },
                undefined
            )
        ];
    }
}


class CylinderNode extends TreeNode {
    point: Point3 = new Point3(0,0,0);
    radius: number = 1;
    height: number = 1;
    zcenter: boolean = true;
    resolution: number = 36;
    constructor(name:string){
        super(name,"cylinder");
        this.properties = [
            new Point3Property("point",
                ()=>{ return this.point},
                (p:Point3) => { 
                    this.point=p;
                }
            ),
            new PositiveNumberProperty("radius",
                ()=>{ return this.radius},
                (r: number) => { 
                    this.radius=r;
                }
            ),
            new PositiveNumberProperty("height",
                ()=>{ return this.height},
                (h: number) => { 
                    this.height=h;
                }
            ),
            new BooleanProperty("Z center",
                ()=>{ return this.zcenter},
                (c: boolean) => { 
                    this.zcenter=c;
                }
            ),
        ];
    }
}


class SphereNode extends TreeNode {
    center: Point3 = new Point3(0,0,0);
    radius: number = 1;
    resolution: number = 36;
    constructor(name:string){
        super(name,"sphere");
        this.properties = [
            new Point3Property("center",
                ()=>{ return this.center},
                (p:Point3) => { 
                    this.center=p;
                }
            ),
            new PositiveNumberProperty("radius",
                ()=>{ return this.radius},
                (r: number) => { 
                    this.radius=r;
                }
            ),
        ];
    }
}

class PythonNode extends TreeNode{
    constructor(name:string){
        super(name,"python");
        this.properties = [];
    }
}


export class TreeEditor{

    treeContainer: HTMLElement;
    propertyContainer: HTMLElement;

    constructor(treeContainer: HTMLElement, propertyContainer: HTMLElement){
        this.treeContainer=treeContainer;
        this.propertyContainer=propertyContainer;

        let treeScroller = document.createElement("div");
        treeScroller.style.overflow="scroll";
        treeScroller.style.height="100%";
        this.treeContainer.appendChild(treeScroller);

        let propertyScroller = document.createElement("div");
        propertyScroller.style.overflow="scroll";
        propertyScroller.style.height="100%";
        this.propertyContainer.appendChild(propertyScroller);



        let r = new DifferenceNode("difference");
        let c1 = new BoxNode("pcbbase");
        let c2 = new UnionNode("holes");
        let g1 = new CylinderNode("hole1cutter");
        let g2 = new CylinderNode("hole2cutter");
        let g3 = new IntersectionNode( "intersection");
        let gg1 = new CylinderNode("cylinder");
        let gg2 = new SphereNode("sphere");
        let gg3 = new PythonNode("script");

        r.appendChild(c1);
        r.appendChild(c2);
        c2.appendChild(g1);
        c2.appendChild(g2);
        c2.appendChild(g3);
        g3.appendChild(gg1);
        g3.appendChild(gg2);
        g3.appendChild(gg3);

        let div = document.createElement("div");
        treeScroller.appendChild(div);

        let types:any={};
        ["box","cylinder","difference","intersection","sphere","union"].forEach( (name:string) => {
            types[name] = {};
            types[name].icon = `./icons/${name}.svg`;
        });


        let tree = $(div).jstree({
            core: {
                data: [r],
                animation: 100,       //default=200
                multiple: false,        //multi-selection
                dblclick_toggle:false,  //allow double click to open/close nodes
                check_callback: ()=>{ 
                    // console.log("CC");
                    return true;
                },
                themes:{
                    dots: true,
                    icons: true
                }
            },

            plugins: [
                "dnd","types",
                "wholerow",         //wholerow overrides the dots option
                "contextmenu",
                // "checkbox",
            ],
            // checkbox:{
            //     visible:true,
            //     whole_node:false,
            // },
            dnd:{
                is_draggable: (n:any) => {
                    console.log("Is draggable?");
                    return true;
                },
                large_drop_target: true,
                blank_space_drop:  true
            },
            contextmenu: {
                select_node: true,  //select node when right clicked
                show_at_node: true, //align menu with node (true) or mouse (false)
                items: (n: any, callback: ContextItemsCallback) => {
                    let I:ContextItemsDict={};
                    I["foo"] = {
                        label:"fooby",
                        action: (selection: ContextItemChosenData) => {
                            console.log("SELECTION 1",selection);
                        }
                    };
                    I["bar"] = {
                        label:"barroom!",
                        action: (selection: ContextItemChosenData) => {
                            console.log("SELECTION 2",selection);
                        }
                    };
                    I["baz"] = {
                        label:"Add child...",
                        submenu : {
                            cylinder: {
                                label:"Cylinder",
                                action: ()=>{}
                            },
                            sphere: {
                                label: "Sphere",
                                action: ()=>{}
                            },
                            boolean: {
                                label: "Boolean...",
                                action: ()=>{},
                                submenu: {
                                    union: {
                                        label: "Union",
                                        action: ()=>{}
                                    },
                                    intersection: {
                                        label: "Intersection",
                                        action: ()=>{}
                                    },
                                    difference: {
                                        label: "Difference",
                                        action: ()=>{}
                                    }
                                }
                            },
                        },
                        action: (selection: ContextItemChosenData) => {
                            console.log("SELECTION 3",selection);
                        }
                    };
                    callback(I);
                }
            },
            types: types
        });
        $(tree).on("select_node.jstree", (e: Event,data: any)=>{
            let n: TreeNode = data.node.original
            console.log("Selected",n);
            while(propertyScroller.childNodes.length){
                propertyScroller.removeChild(propertyScroller.firstChild);
            }
            n.properties.forEach( (p: AnyProperty) => {
                let row = document.createElement("div");
                row.classList.add("propertyrow");

                let namenode = document.createElement("span");
                namenode.style.display="inline-block";
                namenode.classList.add("propertyname");
                namenode.appendChild(document.createTextNode(p.name));
                row.appendChild(namenode);

                switch(p.type){
                    case PropertyType.POINT3:
                    {
                        let p3:Point3 = (p as Point3Property).getValue();
                        let current: number[] = [p3.x,p3.y,p3.z];
                        console.log("current=",current);
                        ["x","y","z"].forEach( (axis:string, idx: number) => {
                            if( p.canSetValue() ){
                                if( idx !== 0)
                                row.appendChild(document.createTextNode(","));
                                let inp = document.createElement("input");
                                inp.size=4;
                                inp.value = current[idx]+"";
                                row.appendChild(inp);
                            } else {
                                console.error("FINISH");
                            }
                        });
                        break;
                    }
                    case PropertyType.NUMBER:
                    case PropertyType.POSITIVE_NUMBER:
                    {
                        if(p.canSetValue()){
                            let inp = document.createElement("input");
                            inp.size=4;
                            row.appendChild(inp);
                            p.addChangeListener( ()=>{
                                let v = (p as NumberProperty).getValue();
                                inp.value = v+"";
                            });
                        } else {
                            let val = document.createElement("span");
                            val.innerHTML = (p as NumberProperty).getValue()+"";
                            row.appendChild(val);
                            p.addChangeListener( ()=>{
                                let v = (p as NumberProperty).getValue();
                                val.innerText = v+"";
                            });
                        }
                        break;  
                    }
                    case PropertyType.BOOLEAN:
                    {
                        if( p.canSetValue() ){
                            let ch = document.createElement("input");
                            ch.type="checkbox";
                            row.appendChild(ch);
                        } else {
                            console.error("finish");
                        }
                        break;
                    }
                    default:
                        console.error("What type is that?",p.name,p.type,
                            PropertyType.NUMBER, PropertyType.POINT3);
                }
                propertyScroller.appendChild(row);
            });
        });
        
    }
}


