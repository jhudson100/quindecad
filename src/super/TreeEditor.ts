
declare var $:any;

export class Point3{
    x:number;
    y:number;
    z:number;
    constructor(x:number, y:number, z:number){
        this.x=x;
        this.y=y;
        this.z=z;
    }
}

interface NodeState{
    opened: boolean;
    disabled: boolean;
    selected: boolean;
}

interface Coordinate{
    x: number;
    y: number;
};

interface ContextItemEntry{
    separator_before?:boolean;
    separator_after?:boolean;
    _disabled?:boolean;
    label:string;
    title?:string;      //tooltip
    action: ContextItemChosenCallback;
    icon?: string;   //if it contains '/': path to icon. Else, css class name
    shortcut?: number;  //keyCode for the action. Ex from jstree docs: F2=113
    shortcut_label?: string;
    submenu?: ContextItemsDict;
};
interface ContextItemChosenData {
    item: ContextItemEntry; //from original item definition
    reference: HTMLElement; //DOM node for the tree node
    element: HTMLElement;   //DOM element for the context menu
    position: Coordinate;   //where the menu is
};

type ContextItemsDict = {[name: string] : ContextItemEntry} ;  //Record<string,ContextItemEntry>;
type ContextItemsCallback = (items: ContextItemsDict) => void;
type ContextItemChosenCallback = ( data:ContextItemChosenData ) => void;

enum PropertyType{
    POINT3, NUMBER, POSITIVE_NUMBER, BOOLEAN
}

type PropertyGetter<T> = ()=>T;
type PropertySetter<T> = (value:T) => void;
class GenericProperty<T>{
    name: string;
    type: PropertyType;
    getter: PropertyGetter<T>;
    setter: PropertySetter<T>;
    constructor(name:string,type: PropertyType, getter: PropertyGetter<T>, setter: PropertySetter<T>){
        this.name=name;
        this.type=type;
        this.getter=getter;
        this.setter=setter;
    }
}

class NumberProperty extends GenericProperty<number>{
    constructor(name:string, getter: PropertyGetter<number>, setter: PropertySetter<number>){
        super(name,PropertyType.NUMBER,getter,setter);
    }
}


class PositiveNumberProperty extends GenericProperty<number>{
    constructor(name:string, getter: PropertyGetter<number>, setter: PropertySetter<number>){
        super(name,PropertyType.POSITIVE_NUMBER,getter,setter);
    }
}


class BooleanProperty extends GenericProperty<boolean>{
    constructor(name:string, getter: PropertyGetter<boolean>, setter: PropertySetter<boolean>){
        super(name,PropertyType.BOOLEAN,getter,setter);
    }
}


class Point3Property extends GenericProperty<Point3>{
    constructor(name:string, getter: PropertyGetter<Point3>, setter: PropertySetter<Point3>){
        super(name,PropertyType.NUMBER,getter,setter);
    }
}

type AnyProperty = NumberProperty|Point3Property|BooleanProperty;

class TreeNode{
    id: string;                 //autogenerated if not present
    text: string;               
    icon: string|boolean;       //If icon contains /: Interpreted as path to image
                                //if false: No icon.
                                //else, interpreted as css class to apply to an <i> element
    state: NodeState;
    children: TreeNode[] = [];
    li_attr: any;               //attributes for the generated li node
    a_attr: any;                 //attributes for the generated a node
    type: string;               //for type jstree plugin

    properties: AnyProperty[] = [];

    constructor(text:string, type: string){
        this.text=text;
        this.state = { 
            opened: true,
            disabled: false,
            selected: false
        };
        this.type=type;
    }
}

class TreeNodeWithChildren extends TreeNode {
    constructor(name: string, type: string){
        super(name,type);
    }
    appendChild(n:TreeNode){
        this.children.push(n);
    }
}

class DifferenceNode extends TreeNodeWithChildren {
    constructor(name: string){
        super(name,"difference");
        this.properties=[];
    }

}


class UnionNode extends TreeNodeWithChildren {
    constructor(name: string){
        super(name,"union");
        this.properties=[];
    }
}



class IntersectionNode extends TreeNodeWithChildren {
    constructor(name: string){
        super(name,"intersection");
        this.properties=[];
    }
}


class BoxNode extends TreeNode {
    min: Point3;
    max: Point3;
    constructor(name:string){
        super(name,"box");
        this.properties = [
            new Point3Property("min",
                ()=>{ return this.min},
                (p:Point3) => { 
                    this.min=p;
                }
            ),
            new Point3Property("max",
                ()=>{ return this.max},
                (p:Point3) => { 
                    this.max=p;
                }
            ),

            //read only properties
            new NumberProperty( "xsize",
                ()=>{ return this.max.x-this.min.x},
                undefined
            ),
            new NumberProperty( "ysize",
                ()=>{ return this.max.y-this.min.y},
                undefined
            ),
            new NumberProperty( "zsize",
                ()=>{ return this.max.z-this.min.z},
                undefined
            ),
            new Point3Property( "centroid",
                ()=>{ 
                    return new Point3(0.5*(this.min.x+this.max.x),
                                      0.5*(this.min.y+this.max.y),
                                      0.5*(this.min.z+this.max.z));
                },
                undefined
            )
        ];
    }
}


class CylinderNode extends TreeNode {
    point: Point3;
    radius: number;
    height: number;
    zcenter: boolean;
    resolution: number = 36;
    constructor(name:string){
        super(name,"cylinder");
        this.properties = [
            new Point3Property("point",
                ()=>{ return this.point},
                (p:Point3) => { 
                    this.point=p;
                }
            ),
            new PositiveNumberProperty("radius",
                ()=>{ return this.radius},
                (r: number) => { 
                    this.radius=r;
                }
            ),
            new PositiveNumberProperty("height",
                ()=>{ return this.height},
                (h: number) => { 
                    this.height=h;
                }
            ),
            new BooleanProperty("Z center",
                ()=>{ return this.zcenter},
                (c: boolean) => { 
                    this.zcenter=c;
                }
            ),
        ];
    }
}


class SphereNode extends TreeNode {
    center: Point3;
    radius: number;
    resolution: number = 36;
    constructor(name:string){
        super(name,"sphere");
        this.properties = [
            new Point3Property("center",
                ()=>{ return this.center},
                (p:Point3) => { 
                    this.center=p;
                }
            ),
            new PositiveNumberProperty("radius",
                ()=>{ return this.radius},
                (r: number) => { 
                    this.radius=r;
                }
            ),
        ];
    }
}

class PythonNode extends TreeNode{
    constructor(name:string){
        super(name,"python");
        this.properties = [];
    }
}


export class TreeEditor{

    parent: HTMLElement;

    constructor(container: HTMLElement){
        this.parent=container;

        let scroller = document.createElement("div");
        scroller.style.overflow="scroll";
        scroller.style.height="100%";
        container.appendChild(scroller);

        let r = new DifferenceNode("difference");
        let c1 = new BoxNode("pcbbase");
        let c2 = new UnionNode("holes");
        let g1 = new CylinderNode("hole1cutter");
        let g2 = new CylinderNode("hole2cutter");
        let g3 = new IntersectionNode( "intersection");
        let gg1 = new CylinderNode("cylinder");
        let gg2 = new SphereNode("sphere");
        let gg3 = new PythonNode("script");

        r.appendChild(c1);
        r.appendChild(c2);
        c2.appendChild(g1);
        c2.appendChild(g2);
        c2.appendChild(g3);
        g3.appendChild(gg1);
        g3.appendChild(gg2);
        g3.appendChild(gg3);

        let div = document.createElement("div");
        scroller.appendChild(div);

        let types:any={};
        ["box","cylinder","difference","intersection","sphere","union"].forEach( (name:string) => {
            types[name] = {};
            types[name].icon = `./icons/${name}.svg`;
        });


        $(div).jstree({
            core: {
                data: [r],
                animation: 100,       //default=200
                multiple: false,        //multi-selection
                dblclick_toggle:false,  //allow double click to open/close nodes
                check_callback: ()=>{ 
                    // console.log("CC");
                    return true;
                },
                themes:{
                    dots: true,
                    icons: true
                }
            },

            plugins: [
                "dnd","types",
                "wholerow",         //wholerow overrides the dots option
                "contextmenu",
                // "checkbox",
            ],
            // checkbox:{
            //     visible:true,
            //     whole_node:false,
            // },
            dnd:{
                is_draggable: (n:any) => {
                    console.log("Is draggable?");
                    return true;
                },
                large_drop_target: true,
                blank_space_drop:  true
            },
            contextmenu: {
                select_node: true,  //select node when right clicked
                show_at_node: true, //align menu with node (true) or mouse (false)
                items: (n: any, callback: ContextItemsCallback) => {
                    let I:ContextItemsDict={};
                    I["foo"] = {
                        label:"fooby",
                        action: (selection: ContextItemChosenData) => {
                            console.log("SELECTION 1",selection);
                        }
                    };
                    I["bar"] = {
                        label:"barroom!",
                        action: (selection: ContextItemChosenData) => {
                            console.log("SELECTION 2",selection);
                        }
                    };
                    I["baz"] = {
                        label:"Add child...",
                        submenu : {
                            cylinder: {
                                label:"Cylinder",
                                action: ()=>{}
                            },
                            sphere: {
                                label: "Sphere",
                                action: ()=>{}
                            },
                            boolean: {
                                label: "Boolean...",
                                action: ()=>{},
                                submenu: {
                                    union: {
                                        label: "Union",
                                        action: ()=>{}
                                    },
                                    intersection: {
                                        label: "Intersection",
                                        action: ()=>{}
                                    },
                                    difference: {
                                        label: "Difference",
                                        action: ()=>{}
                                    }
                                }
                            },
                        },
                        action: (selection: ContextItemChosenData) => {
                            console.log("SELECTION 3",selection);
                        }
                    };
                    callback(I);
                }
            },
            types: types
        });
    }
}


